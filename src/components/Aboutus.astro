---
// TeamWheel.astro - Versión mejorada
// Define los datos del equipo
const team = [
  {
    name: 'Rosana Raposeiras',
    role: 'Frontend GYART',
    image: '/images/rosana.png',
    fallbackImage: '/images/default-avatar.png',
    stack: ['HTML', 'CSS', 'JS', 'Python', 'Java']
  },
  {
    name: 'Persona 2',
    role: 'Backend Dev',
    image: '/images/p2.png',
    fallbackImage: '/images/default-avatar.png',
    stack: ['Node', 'Express', 'MongoDB']
  },
  {
    name: 'Persona 3',
    role: 'Designer',
    image: '/images/p3.png',
    fallbackImage: '/images/default-avatar.png',
    stack: ['Figma', 'Illustrator']
  },
  {
    name: 'Persona 4',
    role: 'Fullstack Dev',
    image: '/images/p4.png',
    fallbackImage: '/images/default-avatar.png',
    stack: ['React', 'Tailwind', 'PostgreSQL']
  },
  {
    name: 'Persona 5',
    role: 'DevOps',
    image: '/images/p5.png',
    fallbackImage: '/images/default-avatar.png',
    stack: ['Docker', 'AWS', 'CI/CD']
  },
  {
    name: 'Persona 6',
    role: 'QA Tester',
    image: '/images/p6.png',
    fallbackImage: '/images/default-avatar.png',
    stack: ['Selenium', 'Jest']
  }
];

const teamLength = team.length;
---

<div 
  id="team-wheel-section" 
  class="flex flex-col md:flex-row items-center justify-center min-h-screen bg-gray-900 text-white gap-8 p-4 md:p-8"
  aria-label="Equipo de desarrollo"
>
  <!-- Wheel -->
  <div 
    id="team-wheel" 
    class="relative w-64 h-64 md:w-80 md:h-80 mb-8 md:mb-0"
    aria-label="Rueda de selección de miembros del equipo"
  >
    <div class="wheel-container w-full h-full rounded-full border-2 border-gray-700 transition-transform duration-700">
      {team.map((member, index) => {
        const angle = (index * 360) / teamLength;
        return (
          <button
            type="button"
            data-index={index}
            class="wheel-item absolute w-14 h-14 -mt-7 -ml-7 rounded-full flex items-center justify-center font-bold bg-gray-700 text-white cursor-pointer transition-all duration-500 opacity-0 shadow-md hover:scale-110 focus:outline-none focus:ring-2 focus:ring-white"
            style={`top: 50%; left: 50%; transform: rotate(${angle}deg) translate(120px) rotate(-${angle}deg);`}
            aria-label={`Seleccionar a ${member.name}`}
            aria-pressed={index === 0 ? "true" : "false"}
            tabindex="0"
          >
            {index + 1}
          </button>
        );
      })}
    </div>
  </div>

  <!-- Info panel -->
  <div 
    id="info-panel" 
    class="max-w-xs md:max-w-sm w-full bg-gray-800 rounded-xl p-6 text-center opacity-0 transition-opacity duration-500 shadow-xl"
    aria-live="polite"
  >
    <div class="flex justify-center mb-4">
      <img 
        id="member-image"
        src={team[0].image}
        alt={`Foto de ${team[0].name}`}
        class="w-24 h-24 md:w-32 md:h-32 rounded-full mx-auto border-4 border-white object-cover" 
      />
    </div>
    <h2 id="member-name" class="text-xl md:text-2xl font-bold mb-2">{team[0].name}</h2>
    <p id="member-role" class="mb-4 text-gray-300">{team[0].role}</p>
    <div id="member-stack" class="flex flex-wrap justify-center gap-2">
      {team[0].stack.map(skill => (
        <span class="bg-gray-700 px-3 py-1 rounded-full text-sm font-medium border border-gray-600 inline-block">
          {skill}
        </span>
      ))}
    </div>
  </div>

  <!-- Controles accesibles -->
  <div class="sr-only">
    <button id="prev-member" aria-label="Miembro anterior">Anterior</button>
    <button id="next-member" aria-label="Siguiente miembro">Siguiente</button>
  </div>
</div>

<script>
  // Esperamos a que se cargue completamente el DOM
  document.addEventListener('DOMContentLoaded', function() {
    // Datos del equipo pasados desde Astro
    const teamData = {team};
    const teamLength = teamData.team.length;
    
    // Elementos DOM
    const wheelSection = document.getElementById('team-wheel-section');
    const wheelContainer = document.querySelector('.wheel-container');
    const wheelItems = document.querySelectorAll('.wheel-item');
    const infoPanel = document.getElementById('info-panel');
    const memberImage = document.getElementById('member-image');
    const memberName = document.getElementById('member-name');
    const memberRole = document.getElementById('member-role');
    const memberStack = document.getElementById('member-stack');
    const prevButton = document.getElementById('prev-member');
    const nextButton = document.getElementById('next-member');
    
    // Estado
    let activeIndex = 0;
    let isAnimating = false;
    let isInitialized = false;
    let observer;
    
    // Función para inicializar la observación de intersección
    function setupIntersectionObserver() {
      observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isInitialized) {
            initializeWheel();
          }
        });
      }, { threshold: 0.3 });
      
      observer.observe(wheelSection);
    }
    
    // Función para inicializar la rueda
    function initializeWheel() {
      if (isInitialized) return;
      isInitialized = true;
      
      // Animar la entrada de los items
      wheelItems.forEach((item, index) => {
        setTimeout(() => {
          item.classList.add('animate-in');
          item.style.opacity = '1';
          
          // Cuando todos los items están visibles, mostrar el panel de info
          if (index === wheelItems.length - 1) {
            setTimeout(() => {
              setActiveMember(0, false);
              infoPanel.style.opacity = '1';
            }, 300);
          }
        }, 150 * index);
      });
      
      // Desconectar el observer una vez inicializado
      if (observer) {
        observer.disconnect();
      }
    }
    
    // Función para actualizar el miembro activo
    function setActiveMember(index, animate = true) {
      if (isAnimating) return;
      
      // Verificar que el índice sea válido
      if (index < 0) index = teamLength - 1;
      if (index >= teamLength) index = 0;
      
      activeIndex = index;
      const member = teamData.team[index];
      
      // Manejar estado de animación
      if (animate) {
        isAnimating = true;
        setTimeout(() => { isAnimating = false; }, 500);
      }
      
      // Actualizar el panel de información
      memberName.textContent = member.name;
      memberRole.textContent = member.role;
      
      // Manejar la imagen con fallback
      memberImage.onerror = function() {
        this.src = member.fallbackImage || '/images/default-avatar.png';
      };
      memberImage.src = member.image;
      memberImage.alt = `Foto de ${member.name}`;
      
      // Actualizar las etiquetas de tecnología
      memberStack.innerHTML = '';
      member.stack.forEach(skill => {
        const span = document.createElement('span');
        span.className = 'bg-gray-700 px-3 py-1 rounded-full text-sm font-medium border border-gray-600 inline-block';
        span.textContent = skill;
        memberStack.appendChild(span);
      });
      
      // Actualizar los states de los items de la rueda
      wheelItems.forEach((item, i) => {
        // Calcular ángulos para rotación suave
        const angle = (i * 360) / teamLength;
        const offsetAngle = (activeIndex * 360) / teamLength;
        
        // Aplicar transformación con CSS para mejor rendimiento
        wheelContainer.style.transform = `rotate(${-offsetAngle}deg)`;
        
        // Actualizar estados ARIA y visuales
        if (i === index) {
          item.classList.add('bg-white', 'text-gray-900');
          item.classList.remove('bg-gray-700', 'text-white');
          item.setAttribute('aria-pressed', 'true');
        } else {
          item.classList.remove('bg-white', 'text-gray-900');
          item.classList.add('bg-gray-700', 'text-white');
          item.setAttribute('aria-pressed', 'false');
        }
      });
    }
    
    // Configurar evento de click para cada item
    wheelItems.forEach((item) => {
      item.addEventListener('click', () => {
        const index = parseInt(item.dataset.index);
        setActiveMember(index);
      });
      
      // Añadir soporte para teclado
      item.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const index = parseInt(item.dataset.index);
          setActiveMember(index);
        } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          e.preventDefault();
          setActiveMember(activeIndex + 1);
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          setActiveMember(activeIndex - 1);
        }
      });
    });
    
    // Configurar navegación con botones accesibles
    prevButton.addEventListener('click', () => setActiveMember(activeIndex - 1));
    nextButton.addEventListener('click', () => setActiveMember(activeIndex + 1));
    
    // Configurar navegación con rueda del mouse
    const wheelDebounce = debounce((direction) => {
      setActiveMember(activeIndex + direction);
    }, 200);
    
    wheelSection.addEventListener('wheel', (e) => {
      if (isInitialized && isInViewport(wheelSection)) {
        e.preventDefault();
        const direction = e.deltaY > 0 ? 1 : -1;
        wheelDebounce(direction);
      }
    }, { passive: false });
    
    // Helper: verificar si un elemento está en el viewport
    function isInViewport(element) {
      const rect = element.getBoundingClientRect();
      return (
        rect.top <= (window.innerHeight || document.documentElement.clientHeight) * 0.7 &&
        rect.bottom >= 0
      );
    }
    
    // Helper: debounce para mejorar rendimiento
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    
    // Inicializar observador para cargar cuando sea visible
    setupIntersectionObserver();
    
    // Comprobar si ya es visible en carga inicial
    if (isInViewport(wheelSection)) {
      initializeWheel();
    }
    
    // Manejar cambios de visibilidad de la página
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && isInViewport(wheelSection)) {
        initializeWheel();
      }
    });
    
    // Manejar eventos de teclado globales
    document.addEventListener('keydown', (e) => {
      if (!isInitialized) return;
      
      if (e.key === 'ArrowRight' && document.activeElement.tagName !== 'BUTTON') {
        setActiveMember(activeIndex + 1);
      } else if (e.key === 'ArrowLeft' && document.activeElement.tagName !== 'BUTTON') {
        setActiveMember(activeIndex - 1);
      }
    });
  });
</script>

<style>
  /* Estilos base */
  .wheel-item {
    z-index: 1;
    transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1);
    opacity: 0;
  }
  
  /* Estilos para el estado activo */
  .wheel-item.bg-white {
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    transform-origin: center;
    z-index: 10;
  }
  
  /* Animación de entrada */
  .wheel-item.animate-in {
    animation: popIn 0.5s forwards;
  }
  
  @keyframes popIn {
    0% {
      opacity: 0;
      transform-origin: center;
      transform: scale(0.5) rotate(0deg) translate(120px) rotate(0deg);
    }
    100% {
      opacity: 1;
      transform-origin: center;
    }
  }
  
  /* Mejoras para accesibilidad en focus */
  .wheel-item:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5);
  }
  
  /* Transición suave para el panel de información */
  #info-panel {
    transition: opacity 0.5s ease-in-out;
  }
  
  /* Mejoras responsive */
  @media (max-width: 768px) {
    .wheel-container {
      transform-origin: center;
    }
    
    .wheel-item {
      width: 3rem;
      height: 3rem;
      margin-top: -1.5rem;
      margin-left: -1.5rem;
    }
  }
</style>